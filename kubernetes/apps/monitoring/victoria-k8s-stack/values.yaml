global:
  clusterLabel: cluster
  license:
    key: ""
    keyRef: {}
  cluster:
    dnsDomain: cluster.local

nameOverride: ""
fullnameOverride: ""
tenant: ""
argocdReleaseOverride: "argo-cd"

victoria-metrics-operator:
  enabled: true
  crds:
    plain: true
    cleanup:
      enabled: true
      image:
        repository: bitnami/kubectl
        pullPolicy: IfNotPresent
  serviceMonitor:
    enabled: true
  operator:
    disable_prometheus_converter: false
    webhook:
      enabled: true

defaultDashboards:
  enabled: true
  defaultTimezone: utc
  labels: {}
  annotations: {}
  grafanaOperator:
    enabled: false
    spec:
      instanceSelector:
        matchLabels:
          dashboards: grafana
      allowCrossNamespaceImport: true
  dashboards:
    victoriametrics-vmalert:
      enabled: true
    victoriametrics-operator:
      enabled: true
    # -- In ArgoCD using client-side apply this dashboard reaches annotations size limit and causes k8s issues without server side apply
    # See [this issue](https://github.com/VictoriaMetrics/helm-charts/tree/master/charts/victoria-metrics-k8s-stack#metadataannotations-too-long-must-have-at-most-262144-bytes-on-dashboards)
    node-exporter-full:
      enabled: true

defaultRules:
  additionalGroupByLabels: []
  create: true

  group:
    spec:
      params: {}
  rule:
    spec:
      labels: {}
      annotations: {}
  alerting:
    spec:
      labels: {}
      annotations: {}
  recording:
    spec:
      labels: {}
      annotations: {}
  rules: {}
  groups:
    etcd: {create: true, rules: {}}
    general: {create: true, rules: {}}
    k8sContainerCpuLimits: {create: true, rules: {}}
    k8sContainerCpuRequests: {create: true, rules: {}}
    k8sContainerCpuUsageSecondsTotal: {create: true, rules: {}}
    k8sContainerMemoryLimits: {create: true, rules: {}}
    k8sContainerMemoryRequests: {create: true, rules: {}}
    k8sContainerMemoryRss: {create: true, rules: {}}
    k8sContainerMemoryCache: {create: true, rules: {}}
    k8sContainerMemoryWorkingSetBytes: {create: true, rules: {}}
    k8sContainerMemorySwap: {create: true, rules: {}}
    k8sPodOwner: {create: true, rules: {}}
    k8sContainerResource: {create: true, rules: {}}
    kubeApiserver: {create: true, rules: {}}
    kubeApiserverAvailability: {create: true, rules: {}}
    kubeApiserverBurnrate: {create: true, rules: {}}
    kubeApiserverHistogram: {create: true, rules: {}}
    kubeApiserverSlos: {create: true, rules: {}}
    kubelet: {create: true, rules: {}}
    kubePrometheusGeneral: {create: true, rules: {}}
    kubePrometheusNodeRecording: {create: true, rules: {}}
    kubernetesApps: {create: true, rules: {}, targetNamespace: ".*"}
    kubernetesResources: {create: true, rules: {}}
    kubernetesStorage: {create: true, rules: {}, targetNamespace: ".*"}
    kubernetesSystem: {create: true, rules: {}}
    kubernetesSystemKubelet: {create: true, rules: {}}
    kubernetesSystemApiserver: {create: true, rules: {}}
    kubernetesSystemControllerManager: {create: true, rules: {}}
    kubeScheduler: {create: true, rules: {}}
    kubernetesSystemScheduler: {create: true, rules: {}}
    kubeStateMetrics: {create: true, rules: {}}
    nodeNetwork: {create: true, rules: {}}
    node: {create: true, rules: {}}
    vmagent: {create: true, rules: {}}
    vmsingle: {create: true, rules: {}}
    vmcluster: {create: true, rules: {}}
    vmHealth: {create: true, rules: {}}
    vmoperator: {create: true, rules: {}}
    alertmanager: {create: true, rules: {}}
  runbookUrl: https://runbooks.prometheus-operator.dev/runbooks
  labels: {}
  annotations: {}

additionalVictoriaMetricsMap: {}

external:
  grafana:
    host: ""
    datasource: VictoriaMetrics
  vm:
    read:
      url: ""
    write:
      url: ""

vmsingle:
  enabled: false

vmcluster:
  enabled: true
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8428"
  spec:
    retentionPeriod: "90d"
    replicationFactor: 2
    vmstorage:
      replicaCount: 3
      storageDataPath: /vm-data
      terminationGracePeriodSeconds: 300
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: app.kubernetes.io/component
                    operator: In
                    values: [ "vmstorage" ]
              topologyKey: "kubernetes.io/hostname"
      extraArgs:
        dedup.minScrapeInterval: "15s"
        search.maxUniqueTimeseries: "300000000"
      storage:
        volumeClaimTemplate:
          spec:
            storageClassName: "ceph-block"
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 100Gi
      resources:
        limits:
          cpu: "4"
          memory: 8Gi
        requests:
          cpu: "2"
          memory: 4Gi
    vmselect:
      enabled: true
      port: "8481"
      replicaCount: 2
      cacheMountPath: /select-cache
      extraArgs: {}
      resources:
        limits:
          cpu: "2"
          memory: 4Gi
        requests:
          cpu: "500m"
          memory: 1Gi
      storage:
        volumeClaimTemplate:
          spec:
            storageClassName: "ceph-block"
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 30Gi
    vminsert:
      enabled: true
      port: "8480"
      replicaCount: 2
      extraArgs: {}
      resources:
        limits:
          cpu: "2"
          memory: 2Gi
        requests:
          cpu: "500m"
          memory: 512Mi
  ingress:
    storage:
      enabled: true
      annotations:
        kubernetes.io/cluster-issuer: "letsencrypt-production"
      labels:
        app: victoria-metrics
        component: storage
      ingressClassName: "internal"
      pathType: Prefix
      path: "/"
      hosts:
        - vmstorage.wakkalabs.com
      extraPaths: []
      tls:
        - secretName: monitoring-wildcard-tls
          hosts:
            - vmstorage.wakkalabs.com
    select:
      enabled: true
      annotations:
        kubernetes.io/cluster-issuer: "letsencrypt-production"
      labels:
        app: victoria-metrics
        component: select
      ingressClassName: "internal"
      pathType: Prefix
      path: "/"
      hosts:
        - vmselect.wakkalabs.com
      extraPaths: []
      tls:
        - secretName: monitoring-wildcard-tls
          hosts:
            - vmselect.wakkalabs.com
    insert:
      enabled: true
      annotations:
        kubernetes.io/cluster-issuer: "letsencrypt-production"
      labels:
        app: victoria-metrics
        component: insert
      ingressClassName: "internal"
      pathType: Prefix
      path: "/"
      hosts:
        - vminsert.wakkalabs.com
      extraPaths: []
      tls:
        - secretName: monitoring-wildcard-tls
          hosts:
            - vminsert.wakkalabs.com

alertmanager:
  enabled: true
  annotations: {}
  spec:
    replicaCount: 1
    port: "9093"
    selectAllByDefault: true
    externalURL: "https://alertmanager.wakkalabs.com"
    routePrefix: /
    configSecret: "alertmanager-config"
  useManagedConfig: false
  config:
    route:
      receiver: "blackhole"
    receivers:
      - name: blackhole
  monzoTemplate:
    enabled: true
  templateFiles: {}
  ingress:
    enabled: true
    annotations:
      kubernetes.io/cluster-issuer: "letsencrypt-production"
    labels: {}
    ingressClassName: "internal"
    path: "/"
    pathType: Prefix
    hosts:
      - alertmanager.wakkalabs.com
    extraPaths: []
    tls:
      - secretName: monitoring-wildcard-tls
        hosts:
          - alertmanager.wakkalabs.com

vmalert:
  annotations: {}
  enabled: true
  remoteWriteVMAgent: false
  spec:
    port: "8080"
    selectAllByDefault: true
    evaluationInterval: 20s
    extraArgs:
      http.pathPrefix: "/"
    externalLabels: {}
  templateFiles: {}
  additionalNotifierConfigs: {}
  ingress:
    enabled: true
    annotations:
      kubernetes.io/cluster-issuer: "letsencrypt-production"
    labels: {}
    ingressClassName: "internal"
    path: ""
    pathType: Prefix
    hosts:
      - vmalert.wakkalabs.com
    extraPaths: []
    tls:
      - secretName: monitoring-wildcard-tls
        hosts:
          - vmalert.wakkalabs.com

vmauth:
  enabled: false
  # annotations: {}
  # spec:
  #   port: "8427"
  #   unauthorizedUserAccessSpec:
  #     disabled: false
  #     discover_backend_ips: true
  #     url_map:
  #       - src_paths:
  #           - '/.*'
  #         url_prefix:
  #           - 'http://vmselect-victoria-metrics-k8s-stack.monitoring.svc.cluster.local:8481/'
  #       - src_paths:
  #           - '/.*'
  #         url_prefix:
  #           - 'http://vminsert-victoria-metrics-k8s-stack.monitoring.svc.cluster.local:8480/'

vmagent:
  enabled: true
  annotations: {}
  additionalRemoteWrites: []
  spec:
    port: "8429"
    selectAllByDefault: true
    scrapeInterval: 20s
    externalLabels: {}
    extraArgs:
      promscrape.streamParse: "true"
      promscrape.dropOriginalLabels: "true"
  ingress:
    enabled: true
    annotations:
      kubernetes.io/cluster-issuer: "letsencrypt-production"
    labels: {}
    ingressClassName: "internal"
    path: ""
    pathType: Prefix
    hosts:
      - vmagent.wakkalabs.com
    extraPaths: []
    tls:
      - secretName: monitoring-wildcard-tls
        hosts:
          - vmagent.wakkalabs.com

grafana:
  enabled: true
  adminPassword: admin
  defaultDashboardsEnabled: false

  # Properly structured dashboard providers
  dashboardProviders: {}

  # Fix the sidecar with proper provider structure
  sidecar:
    dashboards:
      enabled: true
      label: grafana_dashboard
      searchNamespace: ALL
      folderAnnotation: grafana_folder
      provider:
        name: default
        orgid: 1
        folder: ''
        type: file
        disableDeletion: false
        allowUiUpdates: false
  # Add a postStart hook to clean up duplicate dashboards

  readinessProbe:
    httpGet:
      path: /api/health
      port: 3000
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 3
    successThreshold: 1
  forceDeployDatasource: true
  ingress:
    enabled: true
    ingressClassName: "internal"
    annotations:
      kubernetes.io/cluster-issuer: "letsencrypt-production"
    labels:
      app: grafana
    path: /
    pathType: Prefix
    hosts:
      - grafana.wakkalabs.com
    extraPaths: []
    tls:
      - secretName: monitoring-wildcard-tls
        hosts:
          - grafana.wakkalabs.com
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - port: http-metrics
          scheme: https
          tlsConfig:
            ca:
              secret:
                name: etcd-client-certs
                key: etcd-ca.crt
            cert:
              secret:
                name: etcd-client-certs
                key: etcd-client.crt
            keySecret:
              name: etcd-client-certs
              key: etcd-client.key

prometheus-node-exporter:
  enabled: true
  service:
    labels:
      jobLabel: node-exporter
  extraArgs:
    - --collector.filesystem.ignored-mount-points=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/.+)($|/)
    - --collector.filesystem.ignored-fs-types=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|erofs|sysfs|tracefs)$
  vmScrape:
    enabled: true
    spec:
      jobLabel: jobLabel
      selector:
        matchLabels:
          app.kubernetes.io/name: 'prometheus-node-exporter'
      endpoints:
        - port: metrics
          metricRelabelConfigs:
            - action: drop
              source_labels: [ mountpoint ]
              regex: "/var/lib/kubelet/pods.+"

kube-state-metrics:
  enabled: true
  vmScrape:
    enabled: true
    spec:
      selector:
        matchLabels:
          app.kubernetes.io/name: 'kube-state-metrics'
          app.kubernetes.io/instance: 'victoria-metrics-k8s-stack'
      endpoints:
        - port: http
          honorLabels: true
          metricRelabelConfigs:
            - action: labeldrop
              regex: (uid|container_id|image_id)
      jobLabel: app.kubernetes.io/name

kubelet:
  enabled: true
  vmScrapes:
    cadvisor:
      enabled: true
      spec:
        path: /metrics/cadvisor
    probes:
      enabled: true
      spec:
        path: /metrics/probes
    resources:
      enabled: true
      spec:
        path: /metrics/resource
    kubelet:
      spec: {}
  vmScrape:
    kind: VMNodeScrape
    spec:
      scheme: "https"
      honorLabels: true
      interval: "30s"
      scrapeTimeout: "5s"
      tlsConfig:
        insecureSkipVerify: true
        caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
      bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
      metricRelabelConfigs:
        - action: labeldrop
          regex: (uid)
        - action: labeldrop
          regex: (id|name)
        - action: drop
          source_labels: [ __name__ ]
          regex: (rest_client_request_duration_seconds_bucket|rest_client_request_duration_seconds_sum|rest_client_request_duration_seconds_count)
      relabelConfigs:
        - action: labelmap
          regex: __meta_kubernetes_node_label_(.+)
        - sourceLabels: [ __metrics_path__ ]
          targetLabel: metrics_path
        - targetLabel: job
          replacement: kubelet
      honorTimestamps: false

kubeApiServer:
  enabled: true
  vmScrape:
    spec:
      endpoints:
        - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
          port: https
          scheme: https
          tlsConfig:
            caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
            serverName: kubernetes
      jobLabel: component
      namespaceSelector:
        any: true
      selector:
        matchLabels:
          component: apiserver
          provider: kubernetes

kubeControllerManager:
  enabled: true
  endpoints: []
  service:
    enabled: true
    port: 10257
    targetPort: 10257
    selector:
      component: kube-controller-manager
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
          port: http-metrics
          scheme: https
          tlsConfig:
            caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
            insecureSkipVerify: true

kubeDns:
  enabled: false
  service:
    enabled: false
    ports:
      dnsmasq:
        port: 10054
        targetPort: 10054
      skydns:
        port: 10055
        targetPort: 10055
    selector:
      k8s-app: kube-dns
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - port: http-metrics-dnsmasq
          bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
        - port: http-metrics-skydns
          bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token

coreDns:
  enabled: true
  service:
    enabled: true
    port: 9153
    targetPort: 9153
    selector:
      k8s-app: kube-dns
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - port: http-metrics
          bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token

kubeEtcd:
  enabled: true
  endpoints:
    - 192.168.101.120
    - 192.168.101.121
    - 192.168.101.122
  service:
    enabled: true
    port: 2379
    targetPort: 2379
    selector:
      component: etcd
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - port: metrics
          scheme: https
          tlsConfig:
            ca:
              secret:
                name: etcd-client-certs
                key: etcd-ca.crt
            cert:
              secret:
                name: etcd-client-certs
                key: etcd-client.crt
            keySecret:
              name: etcd-client-certs
              key: etcd-client.key
            insecureSkipVerify: true

kubeScheduler:
  enabled: true
  endpoints: []
  service:
    enabled: true
    port: 10259
    targetPort: 10259
    selector:
      component: kube-scheduler
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
          port: http-metrics
          scheme: https
          tlsConfig:
            caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          insecureSkipVerify: true
kubeProxy:
  enabled: false
  endpoints: []
  service:
    enabled: true
    port: 10249
    targetPort: 10249
    selector:
      k8s-app: kube-proxy
  vmScrape:
    spec:
      jobLabel: jobLabel
      namespaceSelector:
        any: true
      endpoints:
        - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
          port: http-metrics
          scheme: https
          tlsConfig:
            caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          insecureSkipVerify: true

extraObjects: []
